#include "HATS.h"
#include <cmath>
#include <cassert>
#include <vector>

vector<Event> filter_memory(vector<Event> memory, float event_ts, float temp_window){
    // finds all events between [event.ts-temp_window, event.ts)
    float limit_ts = event_ts - temp_window;
    
    // Due to the way it is built we only have to find the first extreme
    // Find it using binary search
    bool found = false;
    LRBound bound = {0, (int)(memory.size() - 1)};
    int pos = 0;
    
    // Step through memeory until extreme found
    // This will be done with a binary search algorithm
    while(bound.left<=bound.right && (found == false)){
        int midpoint = floor((bound.left + bound.right)/2);
        if(memory[midpoint].ts == limit_ts){
            pos = midpoint;
            found = true;
        }else{
            if(limit_ts < memory[midpoint].ts){
                LRBound bound = {bound.left, midpoint-1};
            }else{
                LRBound bound = {midpoint+1, bound.right};
			}
        }
    }           
    //Return all events starting from that index
    // To do this in C++, a new vector will be created and initialized 
    // with all values from pos to end of memeory.
    // If returning wrong, specifically missing the first event, 
    // change pos to pos - 1
    vector<Event> returnMem((memory.begin() + pos), memory.end());
    return returnMem;
}

vector<vector<int>> get_pixel_cell_partition_matrix(int width, int height, int K){
    assert ((width % K == 0) && (height % K == 0));
        int cell_width = floor(width/K);
        int cell_height = floor(height/K);

        vector<vector<int>> matrix(height, vector<int> (width, 0));
        
        for (int i = 0; i < width; i ++) {
            for (int j = 0; j < height; j ++) {
                int pixel_row = floor(i / K);
                int pixel_col = floor(j / K);
                matrix[i][j] = pixel_row*cell_width + pixel_col;
            }
        }
        
        return matrix;
}

vector<vector<vector<vector<float>>>> normalise(vector<vector<vector<vector<float>>>> histograms, vector<vector<int>> event_counter){
	/*
        A characteristic of event-based sensors is that the amount
        of events generated by a moving object is proportional to its
        contrast: higher contrast objects generate more events than
        low contrast objects. To make the cell descriptor more invariant 
        to contrast, we therefore normalize h by the number of events |C| 
        contained in the spatio-temporal window used to compute it. 

    */
    // To get the right size, set result equal to histograms
    vector<vector<vector<vector<float>>>> result = histograms;
    
    // Then set all values to 0
    // To do this, the entire matrix must be stepped over
    // Due to dimensionality of vector, 4 iterators are needed
    for(int i = 0; i < (int)result.size(); i++){
		for(int j = 0; j < (int)result[i].size(); j++){
			for(int k = 0; k < (int)result[i][j].size(); k++){
				for(int h = 0; h < (int)result[i][j][k].size(); h++){
					result[i][j][k][h] = 0;
				}
			}
		}
	}
    
        
    // normalise by stepping over each element in histograms 
    // and dividing by the event count for the corresponding element
    // As above, with a 4D vector, multiple iterators are needed
    for(int i = 0; i < (int)result.size(); i++){
		for(int j = 0; j < (int)result[i].size(); j++){
			for(int k = 0; k < (int)result[i][j].size(); k++){
				for(int h = 0; h < (int)result[i][j][k].size(); h++){
					result[i][j][k][h] = histograms[i][j][k][h]/(event_counter[i][j]+0.1);
				}
			}
		}
	}
	// Return the normalized result
    return result;
}

vector<vector<float>> compute_local_memory_time_surface(Event event_i, vector<Event> filtered_memory, int R, float tau){
	// initialize blank time surface
    vector<vector<float>> time_surface(2*R+1, vector<float> (2*R+1, 0));

    // get the timestamp of the triggering event
    int t_i = event_i.ts;
    
    // for every event in the local memory relevant to the event
    // (relevean both in spatial and temporal terms), do:
    for (int i = 0; i < filtered_memory.size(); i++) {
        Event event_j = filtered_memory[i];
        // compute the time delta
        float delta_t = t_i - event_j.ts;

        // compute contribution to time surface
        float event_value = exp(-delta_t/tau);

        // compute coordinates in the shifted representation
        int shifted_y = event_j.y - (event_i.y - R);
        int shifted_x = event_j.x - (event_i.x - R);

        // sum it to the time surface
        time_surface[shifted_y][shifted_x] += event_value;
    }

    // return the computed time surface
    return time_surface;
}

HATS::HATS(float temp_window=0.1, int width=35, int height=35, float delta_t=0.1, float tau=0.5, int R=7, int K=7){
	this->temp_window = temp_window;
    this->tau = tau;
    this->R = R;
    this->K = K;

    this->cell_width = floor(width/K);
    this->cell_height = floor(height/K);
    this->n_cells = this->cell_width * this->cell_height;
    this->n_polarities = 2;

    this->get_cell = get_pixel_cell_partition_matrix(width, height, K);
    
    this->reset();
}

void HATS::reset(){
	vector<vector<vector<vector<float>>>> temp(this->n_cells, vector<vector<vector<float>>>(this->n_polarities, vector<vector<float>>(2*this->R+1, vector<float>(2*this->R+1, 0))));
    this->histograms = temp;
    vector<vector<int>> temp1(this->n_cells, vector<int>(this->n_polarities, 0));
    this->event_counter = temp1;
    vector<vector<vector<Event>>> temp2(this->n_cells, vector<vector<Event>>(this->n_polarities, vector<Event>(1)));
    this->cell_memory = temp2;
}

void HATS::process(Event ev){
    // Get the cell corresponding to the event
    int cell = this->get_cell[ev.y][ev.x];
    int polarity_index = ev.polarity;

    // If cell_memory is empty, initialize a list with the event, else add it
    if (this->cell_memory[cell][polarity_index].back().ts == 0 && this->cell_memory[cell][polarity_index].size() == 1) {
        this->cell_memory[cell][polarity_index][0] = ev;
    } else {
        this->cell_memory[cell][polarity_index].push_back(ev);
    }

    // Filter Local Memory to only events in Temporal Window
    this-> cell_memory[cell][polarity_index] = filter_memory(this->cell_memory[cell][polarity_index], ev.ts, this->temp_window);

    // Get the Local Memory Time Surface
    vector<vector<float>> time_surface = compute_local_memory_time_surface(ev, this->cell_memory[cell][polarity_index], this->R, this->tau);

    // Add the time surface to the cell histograms
    for (int i=0; i<2*this->R+1; i++) {
        for (int j=0; j<2*this->R+1; j++) {
            this->histograms[cell][polarity_index][i][j] += time_surface[i][j];
        }
    }

    // Increase the event counter for the cell
    this->event_counter[cell][polarity_index] += 1;
}

void HATS::process_all(vector<Event> evs){
	for (int i=0; i<evs.size(); i++) {
        this->process(evs[i]);
    }
    this->histograms = normalise(this->histograms, this->event_counter);
}
