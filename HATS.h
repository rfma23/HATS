#ifndef NUM_H
#define NUM_H

struct LRBound {
    int left = 0;
    int right = 0;
};

struct Event {
    unsigned int x = 0;
    unsigned int y = 0;
    unsigned int ts = 0;
    bool polarity;
};

struct TrainingSample {
    std::vector<float> features;
    std::vector<int> labels;
};

/*
finds all events between [events.ts-temp_window, event.ts)
*/
vector<Event> filter_memory(vector<vector<Event>> memory, float event_ts, float temp_window);

/*
function takes as input the width and the height of the image sensor, and the number 
K which is the size of the C cells which divide the pixel grid. In order to perform 
quick lookup of which is the corresponding cell for each pixl, this function returns 
a matrix containing the index of the corresponding cell for each pixel which makes the 
lookup O(1). The indices are returned in a row manner, i.e:
0 1 2 3 4
5 6 7 8 9
*/
vector<vector<int>> get_pixel_cell_partition_matrix(int width, int height, int K);

/*
A characteristic of event-based sensors is that the amount
of events generated by a moving object is proportional to its
contrast: higher contrast objects generate more events than
low contrast objects. To make the cell descriptor more invariant 
to contrast, we therefore normalize h by the number of events |C| 
contained in the spatio-temporal window used to compute it.
*/
vector<vector<float>> normalise(vector<vector<float>> histograms, int event_counter);

/*
The function takes the a filtered memory containing only 
events in the neighborhood of the event and belonging to the
temporal window that needs to be considered and outputs a time 
surface.
*/
vector<vector<float>> compute_local_memory_time_surface(Event ev, vector<Event> filtered_memory, int R, float tau);

class HATS {
    public:
    HATS(float temp_window, int width, int height, float delta_t, float tau, int R, int K);

    void reset();
    void process(Event ev);
    void process_all(vector<Event> evs);
}

#endif